AI TRANSCRIPT - MIDTERM ASSISTANCE

This document contains examples of prompts and AI interactions that aided in completing the midterm exam. These represent the types of conversations that helped clarify concepts and guide problem-solving approaches.

QUESTION 1 - COHESION ANALYSIS

Prompt: "I need to analyze the cohesion of a StudentPortalHelper class using Arthur Riel's heuristics. The class has methods for GPA calculation, CSV export, email formatting, date formatting, payment processing, password validation, and caching. Can you walk me through how to apply cohesion heuristics to this?"

AI Response: "Let me help you analyze this step by step. First, let's identify the different types of cohesion according to Arthur Riel's heuristics. We have functional cohesion (best), sequential cohesion, communicational cohesion, procedural cohesion, temporal cohesion, logical cohesion, and coincidental cohesion (worst). Looking at your StudentPortalHelper class, I can see methods for GPA calculation, CSV export, email formatting, date formatting, payment processing, password validation, and caching. These serve completely different domains with no logical relationship, which indicates coincidental cohesion. The only evidence of any meaningful cohesion is weak communicational cohesion between the putCache and getCache methods, which share the same data structure. This is a classic example of a 'god class' that tries to do too many things."

Follow-up: "I understand it has low cohesion, but I'm not sure how to approach refactoring it. Can you walk me through how I would break this down using the Single Responsibility Principle?"

QUESTION 2 - METHOD OVERLOADING

Prompt: "I need to create an AreaCalculator class with overloaded methods for different shapes. Can you explain why overloading is better than separate method names like circleArea(), rectangleArea()?"

AI Response: "Method overloading provides a cleaner API because all methods perform the same conceptual operation (calculating area) but with different parameters. This creates a more intuitive interface where users can call area() with the appropriate parameters for their shape without needing to remember different method names like circleArea(), rectangleArea(), etc. The compiler can determine which method to call based on the parameter types and count, making the code more readable and maintainable. It also follows the principle of having a consistent interface for similar operations. However, you need to be careful about parameter validation and make sure each method throws IllegalArgumentException for invalid inputs."

Follow-up: "That makes sense, but I'm struggling with how to explain this in my code comments. Can you help me think through how to articulate why overloading is better than separate method names?"

QUESTION 3 - UML DESIGN ANALYSIS

Prompt: "I have a UML diagram showing Car inheritance hierarchy with Base, Sports, Luxury subclasses, and separate Engine hierarchy. The requirement is to allow dynamic trim-level changes during manufacturing. Can you help me analyze why the current structure doesn't support this?"

AI Response: "The current inheritance-based design creates rigid object types that can't be changed at runtime. Let me walk you through why this is problematic. In the current UML structure, each trim level (Base, Sports, Luxury) is implemented as a separate class that extends Car. Once a car object is instantiated as a specific trim level class, it cannot be transformed into a different trim level without creating an entirely new object. The object's type is determined at creation time and remains fixed throughout its lifetime. If a customer decides to change from a Base trim to a Luxury trim during manufacturing, the system would need to create a new Luxury car object, copy all relevant data from the existing Base car object, discard the original Base car object, and update all references. This process is not only inefficient but also introduces significant complexity and potential for errors. Furthermore, this approach violates the principle of object identity, as the car would essentially become a different object rather than the same car with a modified configuration."

Follow-up: "I see the problem with inheritance, but I'm not sure how to solve it. Can you help me understand how composition would work here to allow dynamic changes?"

QUESTION 4 - INHERITANCE AND INTERFACES

Prompt: "I need to create a smart campus device system with an abstract Device class and interfaces for Networked and BatteryPowered. Can you help me understand how to properly implement multiple interfaces while extending an abstract class?"

AI Response: "In Java, you can extend one class and implement multiple interfaces. Let me show you how to structure this properly. The Device abstract class provides common functionality like id, location, heartbeat, and connection status that all devices share, while requiring each concrete device to implement its own specific getStatus() method. The Networked interface adds connectivity capabilities (connect, disconnect, isConnected), and the BatteryPowered interface adds battery management (getBatteryPercent, setBatteryPercent). A device like DoorLock can extend Device and implement both Networked and BatteryPowered interfaces, while Thermostat might only implement Networked. This design allows for code reuse through inheritance while providing flexible behavior through interfaces. You'll need to make sure each concrete class calls super(id, location) in its constructor and properly implements all required methods from both the abstract class and interfaces."

Follow-up: "I'm confused about some of the concepts here. Can you help me understand why Device should be abstract and whether this design involves multiple inheritance?"


Throughout the exam, AI was used as a:
- Conceptual guide for understanding complex topics
- Practice partner for testing understanding
- Debugging assistant when stuck on specific issues
- Second opinion for validating reasoning approaches

This collaborative approach helped me achieve a deeper understanding of object-oriented design principles, especially in the previous assignment.